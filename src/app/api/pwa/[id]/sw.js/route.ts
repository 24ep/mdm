import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    try {
        const { id } = await params

        const pwa = await db.websitePWA.findUnique({
            where: { id },
        })

        if (!pwa) {
            return NextResponse.json({ error: 'PWA not found' }, { status: 404 })
        }

        // Extract loading config from manifestParams
        const manifestParams = (pwa.manifestParams as any) || {}
        const loadingConfig = manifestParams.loadingConfig || {}

        const bgColor = loadingConfig.backgroundColor || pwa.bgColor || '#ffffff'
        const spinnerColor = loadingConfig.spinnerColor || pwa.themeColor || '#000000'
        const loadingText = loadingConfig.text || ''
        const iconUrl = pwa.iconUrl || ''

        // Generate the loading screen HTML statically
        const iconHtml = iconUrl
            ? `<img src="${iconUrl}" alt="" class="app-icon" onerror="this.style.display='none'">`
            : ''
        const textHtml = loadingText
            ? `<div class="loading-text">${loadingText}</div>`
            : ''

        // Generate the Service Worker JavaScript
        const serviceWorker = `
// PWA Service Worker - Generated by MDM PWA Manager
// PWA ID: ${id}

const CACHE_NAME = 'pwa-${id}-v1';
const LOADING_SCREEN_CACHE = 'pwa-${id}-loading';

// Loading screen HTML with configured styles
const LOADING_SCREEN_HTML = \`<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="${pwa.themeColor || '#ffffff'}">
  <title>${pwa.name || 'Loading...'}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background-color: ${bgColor};
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .loader-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }
    .app-icon {
      width: 80px;
      height: 80px;
      border-radius: 16px;
      object-fit: contain;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid ${spinnerColor}20;
      border-top-color: ${spinnerColor};
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .loading-text {
      font-size: 16px;
      font-weight: 500;
      color: ${spinnerColor};
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div class="loader-container">
    ${iconHtml}
    <div class="spinner"></div>
    ${textHtml}
  </div>
</body>
</html>\`;

// Install event - cache the loading screen
self.addEventListener('install', (event) => {
  console.log('[SW] Installing Service Worker for ${pwa.name}');
  event.waitUntil(
    caches.open(LOADING_SCREEN_CACHE).then((cache) => {
      // Cache a synthetic loading screen response
      const loadingResponse = new Response(LOADING_SCREEN_HTML, {
        headers: { 'Content-Type': 'text/html; charset=utf-8' }
      });
      return cache.put('/_loading', loadingResponse);
    })
  );
  self.skipWaiting();
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating Service Worker for ${pwa.name}');
  event.waitUntil(
    Promise.all([
      self.clients.claim(),
      // Clean old caches if version changes
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((name) => name.startsWith('pwa-${id}-') && name !== CACHE_NAME && name !== LOADING_SCREEN_CACHE)
            .map((name) => caches.delete(name))
        );
      })
    ])
  );
});

// Fetch event - show loading screen for navigation requests
self.addEventListener('fetch', (event) => {
  const request = event.request;
  
  // Only intercept navigation requests (full page loads)
  if (request.mode === 'navigate') {
    event.respondWith(
      (async () => {
        // Strategy: Show loading screen immediately, then fetch actual page
        // For a smoother UX, we use a "stale-while-revalidate" like approach
        
        try {
          // Fetch the actual page
          const networkResponse = await fetch(request);
          
          // If successful, return the real page
          if (networkResponse.ok) {
            return networkResponse;
          }
          
          // If there's an error, try to show cached loading screen
          const cache = await caches.open(LOADING_SCREEN_CACHE);
          const cachedLoading = await cache.match('/_loading');
          if (cachedLoading) {
            return cachedLoading;
          }
          
          // Fallback to network response even if not ok
          return networkResponse;
        } catch (error) {
          // Network error - show loading screen as offline fallback
          console.log('[SW] Network error, showing loading screen');
          const cache = await caches.open(LOADING_SCREEN_CACHE);
          const cachedLoading = await cache.match('/_loading');
          if (cachedLoading) {
            return cachedLoading;
          }
          throw error;
        }
      })()
    );
    return;
  }
  
  // For other requests, just fetch normally
  // Could add caching strategy here for assets if needed
});

// Message handler for cache updates
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

console.log('[SW] Service Worker loaded for ${pwa.name}');
`

        return new NextResponse(serviceWorker, {
            headers: {
                'Content-Type': 'application/javascript',
                'Cache-Control': 'no-cache',
                'Service-Worker-Allowed': '/',
                'Access-Control-Allow-Origin': '*',
            },
        })
    } catch (error) {
        console.error('Error generating PWA service worker:', error)
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
    }
}
