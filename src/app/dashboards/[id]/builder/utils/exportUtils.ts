import { DashboardElement } from '../hooks/useDashboardState'

export interface ExportOptions {
  format: 'csv' | 'json' | 'pdf' | 'png' | 'svg'
  includeMetadata?: boolean
  includeFilters?: boolean
  resolution?: { width: number; height: number }
  quality?: number
}

export interface ExportData {
  element: DashboardElement
  data: any[]
  metadata: {
    elementName: string
    elementType: string
    exportDate: string
    exportFormat: string
    dashboardName: string
  }
}

export class ExportManager {
  static async exportToCSV(data: ExportData): Promise<Blob> {
    if (!data.data || data.data.length === 0) {
      throw new Error('No data available for export')
    }

    const headers = Object.keys(data.data[0])
    const csvContent = [
      // Metadata header
      `# ${data.metadata.elementName} - ${data.metadata.elementType}`,
      `# Exported on: ${data.metadata.exportDate}`,
      `# Dashboard: ${data.metadata.dashboardName}`,
      '',
      // CSV headers
      headers.join(','),
      // CSV data
      ...data.data.map(row => 
        headers.map(header => {
          const value = row[header]
          // Escape values that contain commas, quotes, or newlines
          if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
            return `"${value.replace(/"/g, '""')}"`
          }
          return value
        }).join(',')
      )
    ].join('\n')

    return new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
  }

  static async exportToJSON(data: ExportData): Promise<Blob> {
    const exportObject = {
      metadata: data.metadata,
      data: data.data,
      element: {
        id: data.element.id,
        name: data.element.name,
        type: data.element.type,
        config: data.element.config
      }
    }

    const jsonContent = JSON.stringify(exportObject, null, 2)
    return new Blob([jsonContent], { type: 'application/json;charset=utf-8;' })
  }

  static async exportToPDF(data: ExportData): Promise<Blob> {
    // This would typically use a library like jsPDF or Puppeteer
    // For now, we'll create a simple HTML-based PDF
    const htmlContent = `
      <!DOCTYPE html>
      <html>
        <head>
          <title>${data.metadata.elementName}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            .header { border-bottom: 2px solid #333; padding-bottom: 10px; margin-bottom: 20px; }
            .metadata { background: #f5f5f5; padding: 10px; margin-bottom: 20px; border-radius: 5px; }
            table { width: 100%; border-collapse: collapse; margin-top: 20px; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #f2f2f2; }
            .footer { margin-top: 30px; text-align: center; color: #666; font-size: 12px; }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>${data.metadata.elementName}</h1>
            <p>${data.metadata.elementType} - ${data.metadata.dashboardName}</p>
          </div>
          
          <div class="metadata">
            <p><strong>Export Date:</strong> ${data.metadata.exportDate}</p>
            <p><strong>Format:</strong> ${data.metadata.exportFormat}</p>
            <p><strong>Records:</strong> ${data.data.length}</p>
          </div>

          ${data.data.length > 0 ? `
            <table>
              <thead>
                <tr>
                  ${Object.keys(data.data[0]).map(key => `<th>${key}</th>`).join('')}
                </tr>
              </thead>
              <tbody>
                ${data.data.map(row => `
                  <tr>
                    ${Object.values(row).map(value => `<td>${value}</td>`).join('')}
                  </tr>
                `).join('')}
              </tbody>
            </table>
          ` : '<p>No data available</p>'}

          <div class="footer">
            <p>Generated by Dashboard Builder</p>
          </div>
        </body>
      </html>
    `

    // In a real implementation, you would use a PDF generation library
    // For now, we'll return the HTML as a blob
    return new Blob([htmlContent], { type: 'text/html;charset=utf-8;' })
  }

  static async exportToPNG(element: DashboardElement, options: ExportOptions = { format: 'png' }): Promise<Blob> {
    // This would typically use html2canvas or similar library
    // For now, we'll create a placeholder
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    
    if (!ctx) {
      throw new Error('Could not get canvas context')
    }

    const { width = 800, height = 600 } = options.resolution || {}
    canvas.width = width
    canvas.height = height

    // Draw a placeholder
    ctx.fillStyle = '#f0f0f0'
    ctx.fillRect(0, 0, width, height)
    
    ctx.fillStyle = '#333'
    ctx.font = '24px Arial'
    ctx.textAlign = 'center'
    ctx.fillText(element.name, width / 2, height / 2)
    
    ctx.font = '16px Arial'
    ctx.fillText(`${element.type} - ${element.width}Ã—${element.height}`, width / 2, height / 2 + 40)

    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        resolve(blob!)
      }, 'image/png', options.quality || 0.9)
    })
  }

  static async exportToSVG(element: DashboardElement, data: any[]): Promise<Blob> {
    const svgContent = `
      <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <style>
            .title { font-family: Arial, sans-serif; font-size: 24px; font-weight: bold; }
            .subtitle { font-family: Arial, sans-serif; font-size: 16px; }
            .data-text { font-family: Arial, sans-serif; font-size: 12px; }
          </style>
        </defs>
        
        <rect width="800" height="600" fill="#f8f9fa" stroke="#dee2e6" stroke-width="2"/>
        
        <text x="400" y="50" text-anchor="middle" class="title">${element.name}</text>
        <text x="400" y="80" text-anchor="middle" class="subtitle">${element.type}</text>
        
        ${data.length > 0 ? `
          <g transform="translate(50, 120)">
            ${Object.keys(data[0]).map((key, index) => `
              <text x="${index * 150}" y="0" class="data-text" font-weight="bold">${key}</text>
            `).join('')}
            
            ${data.slice(0, 10).map((row, rowIndex) => 
              Object.values(row).map((value, colIndex) => `
                <text x="${colIndex * 150}" y="${(rowIndex + 1) * 20}" class="data-text">${value}</text>
              `).join('')
            ).join('')}
          </g>
        ` : '<text x="400" y="300" text-anchor="middle" class="subtitle">No data available</text>'}
      </svg>
    `

    return new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8;' })
  }

  static downloadBlob(blob: Blob, filename: string): void {
    const url = window.URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    window.URL.revokeObjectURL(url)
  }

  static generateFilename(element: DashboardElement, format: string): string {
    const timestamp = new Date().toISOString().split('T')[0]
    const sanitizedName = element.name.replace(/[^a-zA-Z0-9]/g, '_')
    return `${sanitizedName}_${timestamp}.${format}`
  }
}

export const exportElement = async (
  element: DashboardElement,
  data: any[],
  format: ExportOptions['format'],
  dashboardName: string = 'Dashboard'
): Promise<void> => {
  const exportData: ExportData = {
    element,
    data,
    metadata: {
      elementName: element.name,
      elementType: element.type,
      exportDate: new Date().toISOString(),
      exportFormat: format.toUpperCase(),
      dashboardName
    }
  }

  let blob: Blob
  const filename = ExportManager.generateFilename(element, format)

  try {
    switch (format) {
      case 'csv':
        blob = await ExportManager.exportToCSV(exportData)
        break
      case 'json':
        blob = await ExportManager.exportToJSON(exportData)
        break
      case 'pdf':
        blob = await ExportManager.exportToPDF(exportData)
        break
      case 'png':
        blob = await ExportManager.exportToPNG(element)
        break
      case 'svg':
        blob = await ExportManager.exportToSVG(element, data)
        break
      default:
        throw new Error(`Unsupported export format: ${format}`)
    }

    ExportManager.downloadBlob(blob, filename)
  } catch (error) {
    throw new Error(`Export failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}
